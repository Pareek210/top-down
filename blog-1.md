# Software Development in the Real World

## Introduction

I graduated from one of the best computer science engineering schools in the world, where I had access to excellent professors, a talented peer group, and guidance from successful seniors. Despite these advantages, it can still be difficult to make the most of this education. Traditional teaching methods often focus on the details without providing a broader understanding of the field. Additionally, a lack of guidance and opportunities to engage with the real-world software development community can make it difficult for young students to develop a passion for the subject. This article is an attempt to provide a top-down view of software development for those new to the field. The goal is to help students understand the landscape and plan their own path with the right information and resources.

To avoid getting lost in the details, it's important to keep the broader goals of your education in mind. In my opinion, some reasonable targets to aim for include:

1. Gaining a basic understanding of computers
2. Getting a feel for software development
3. Choosing a language for basic programming practice
4. Learning the primary theoretical concepts of computer science
5. Mastering the primary concepts of basic programming
6. Developing routines for sharpening math and logic skills
7. Generating excitement for the potential of software businesses

This is an evolving list, and each of these areas includes many sub-categories. It's a good idea to regularly revisit these overarching goals and take a step back to assess your progress.

## Fundamentals of Software Development

If we were to select a group of 100 first-year university students from any institution in the country, it's likely that their familiarity with computers would vary greatly. While access to technology has improved in recent years, many people's primary interaction with computers is still limited to their smartphones. They may also have a desktop or laptop for common tasks like writing documents, watching movies, browsing the web, and playing games. Few students come to university with a background in the inner workings of computers.

In this section, I don't aim to reinvent the wheel, but rather to curate the excellent content that is already available. I will provide guidance and suggestions to help you navigate this material. As you learn, be sure to supplement your knowledge with your own research on YouTube and other sources. The key is to develop curiosity and explore new concepts. Over time, you should aim to identify your preferred sources of information and learning materials that suit your style. Some of the major topics to cover on this track include:

### Early Computing Machines

Early computing machines were mechanical or electro-mechanical devices that were used to perform calculations. One of the earliest computing machines was the abacus, which was used for basic arithmetic operations. The abacus is a frame with beads that can be moved along wires or rods to represent numbers and perform calculations.

As technology advanced, more complex computing machines were developed, such as the mechanical calculators that were used in the 19th and early 20th centuries. These machines were operated by turning a crank or pressing a button to perform calculations.

In the mid-20th century, electronic calculators were developed, which used electronic circuits and components to perform calculations. These machines were faster and more versatile than their mechanical predecessors, but they were still relatively limited in their capabilities.

In the 1950s, more powerful computers were developed, such as the UNIVAC and IBM 701, which used vacuum tubes and other early electronic components to perform complex calculations and store and manipulate data. These machines were the precursors to the modern computers that we use today.

1. [Basics of Computers - Quick Guide](https://www.tutorialspoint.com/basics_of_computers/basics_of_computers_quick_guide.html)
2. [Early Days of Computing - Know the Code](https://knowthecode.io/labs/evolution-of-computing/episode-2)
